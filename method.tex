% !TEX root = thesis.tex

%%
%%
%% Method chapter
%%
%%

In this chapter, we describe the methods used to examine the statistical performance of the \gls{dkd}.
The basic unit is the \textit{experiment}, a set of simulations run with the same initial setup with the same measurements taken.
Each experiment is run with a fixed set of parameters, described below in \Cref{tab:experimental_parameters}.
We then run a set of experiments, varying one parameter at a time, or in some cases two parameters in tandem, in order to observe the effect of this parameter on the accuracy of the \gls{dkd}.

\begin{table}[htbp]
    \centering
    \begin{tabular}{ll}
    Parameter name & Description \\
    \hline
    x1.min & Minimum value of the study area in the horizontal (\(X_1\)) direction \\
    x1.max & Maximum value of the study area in the horizontal (\(X_1\)) direction  \\
    x2.min & Minimum value of the study area in the vertical (\(X_2\)) direction \\
    x2.max & Maximum value of the study area in the vertical (\(X_2\)) direction \\
    grid.by & Space between grid points in the study area \\
    buffer & Buffer around outside of study area \\
    N.p & Size of population \\
    EN.i & Expected number of incidents per simulation \\
    c1 & (optional) \(X_1\) coordinate of the population peak \\
    c2 & (optional) \(X_2\) coordinate of the population peak \\
    sigma1 & (optional) \(X_1\) standard deviation of the population peak \\
    sigma2 & (optional) \(X_2\) standard deviation of the population peak \\
    rho & (optional) Correlation coefficient of \(X_1\) and \(X_2\) \\
    bandwidths & List of bandwidths for evaluating the Oracle \\
    incident\textunderscore rate & Risk function for generating incidents from population \\
    \end{tabular}
    \caption{Experimental parameters}
    \label{tab:experimental_parameters}
\end{table}

\Cref{sec:method:experiment_structure} describes the steps of each experiment, together with the measurements taken.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Section: computing the dkd
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing the DKD}
\label{sec:method:computing}

The \gls{dkd} is computed over the study area as the ratio of two positive-valued functions.
At any given point \((x_1, x_2)\) in the plane, we can compute \gls{lambda_i}\((x_1, x_2)\), the \gls{factor} at that point.
We call \gls{lambda_i}\((x_1, x_2)\) the \textit{incident intensity} at \((x_1, x_2)\).
Next, at the same point, we can compute \gls{lambda_p}\((x_1, x_2)\), the population \textit{population intensity} at \((x_1, x_2)\).
Ideally, we would know how to compute these functions exactly, and we would then compute \(\lambda(x_1, x_2)\) the risk,
or probability of an incident at \((x_1, x_2)\) with the ratio:
\begin{equation}
    \lambda(x_1, x_2) = \frac{\gls{lambda_i}(x_1, x_2)}{\gls{lambda_p}(x_1, x_2)}.
\end{equation}

Since we assume that we cannot compute \gls{lambda_i}\((x_1, x_2)\) and \gls{lambda_p}\((x_1, x_2)\) exactly,
we approximate them as follows.

TBD intensity kernel

For simplicity of computation, we do not account for edge effects.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Section: accuracy measures
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Measuring the accuracy of the DKD}
\label{sec:method:accuracy}

In order to describe the accuracy of the \gls{dkd} as a method of estimating the true risk function \(\lambda\),
we use several accuracy measures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subsection: MISE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MISE}
\label{subsec:method:mise}

\Gls{mise} is a measure of the expected squared difference between an estimated risk function \gls{lambda_hat},
computed using the \gls{dkd}, and the true risk function \gls{lambda}.
\Gls{mise} allows for additional analysis by being broken down into the mean integraged bias and mean integrated variance.
It can also be easily approximated by cross-validation error.

For any given data sample, we can use the \gls{dkd} to compute the estimated risk function \gls{lambda_hat}.
We then integrate the squared error in the estimate over the plane to obtain the \gls{ise}.

\begin{equation}
\label{eq:ise}
    \mbox{ISE}(\hat{\lambda}) = 
        \int_{-\infty}^{\infty} \int_{-\infty}^{\infty}
            \left(
                \hat{\lambda}(x_1, x_2) - \lambda(x_1, x_2)
            \right)^2 \diff{x_2} \diff{x_1}
\end{equation}

We can then compute the expected value of the \gls{ise} to obtain the \gls{mise}.

\begin{equation}
\label{eq:mise}
    \mbox{MISE} = \E [\mbox{ISE}(\hat{\lambda})]
\end{equation}

In our experiments, we run \(M\) monte carlo simulations, and approximate the \gls{mise} by taking the empirical average of the \glspl{ise}.

\begin{equation}
    \widetilde{\mbox{MISE}} = \frac{1}{M} \sum_{i=1}^{M} \mbox{ISE}(\hat{\lambda_i})
\end{equation}


In many of our analyses, we compare the accuracy of several experiments.
\gls{mise} is computed from the \gls{ise},
and \gls{ise} as computed using \cref{eq:ise}.
For any \(\gls{lambda_hat} = \gls{mu} \hat f \),
we have \( \gls{mise}(\gls{lambda_hat}) = \gls{mu}^2 \gls{mise}(\hat f) \).

We observe that \gls{mise} will naturally increase with \gls{mu} when computed in an absolute sense.
We provide two variations of the \gls{mise} that compensate for this.
First, we compute \gls{rmise} by dividing \(\gls{lambda_hat}(x_1, x_2)\) by \(\gls{lambda}(x_1, x_2)\) at every point \(x_1, x_2\) in the evaluation grid, and computing
\begin{equation}
\label{eq:rmise}
    \mbox{\gls{rmise}}(\gls{lambda_hat}) = 
        \mbox{\gls{mise}}(\gls{relative_lambda_hat}) \\
\end{equation}
where
\begin{equation}
\label{eq:relative_lambda_hat}
    \gls{relative_lambda_hat}(x_1, x_2) = 
        \frac{\gls{lambda_hat}(x_1, x_2)}{\gls{lambda}(x_1, x_2)}
        \text{.}
\end{equation}

Next, we \textit{normalize} the \gls{mise} by dividing by \(\gls{mu}^2\),
which we call \gls{nmise}:
\begin{equation}
\label{eq:nmise}
    \mbox{\gls{nmise}}(\gls{lambda_hat}) = 
        \frac{1}{\gls{mu}^2} \mbox{\gls{mise}}(\gls{lambda_hat}) \text{.}
\end{equation}

In many cases it is more informative to compare the accuracy of two experiments using \gls{nmise} and \gls{rmise} than using \gls{mise}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subsection: MIAE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MIAE}
\label{subsec:method:miae}

\Gls{miae} is a measure of the expected absolute difference between an estimated risk function \gls{lambda_hat},
computed using the \gls{dkd}, and the true risk function \gls{lambda}.
\Gls{miae} differs from \gls{mise} by on the one hand providing a more intuitive comparison,
since we are comparing the absolute difference instead of the squared difference.
On the other hand, it lacks some of the nice mathematical properties of the \gls{mise}.

As we did in \autoref{subsec:method:mise}, for any given data sample we use the \gls{dkd} to compute the estimated risk function \gls{lambda_hat}.
We then integrate the absolute value of the error in the estimate over the plane to obtain the \gls{ise}.

\begin{equation}
    \mbox{IAE}(\hat{\lambda}) = 
        \int_{-\infty}^{\infty} \int_{-\infty}^{\infty}
            \left|
                \hat{\lambda}(x_1, x_2) - \lambda(x_1, x_2)
            \right| \diff{x_2} \diff{x_1}
\end{equation}

We can then compute the expected value of the \gls{ise} to obtain the \gls{mise}.

\begin{equation}
    \mbox{MIAE} = \E [\mbox{IAE}(\hat{\lambda})]
\end{equation}

As above, we run \(M\) monte carlo simulations,
and approximate the \gls{miae} by taking the empirical average of the \glspl{iae}.

\begin{equation}
    \widetilde{\mbox{MIAE}} = \frac{1}{M} \sum_{i=1}^{M} \mbox{IAE}(\hat{\lambda_i})
\end{equation}

As with \gls{mise}, we need to compare experiments with different values of \gls{mu}.
The analogous definitions are \gls{rmiae} and \gls{nmiae}, as defined below.

\begin{equation}
\label{eq:rmiae}
    \mbox{\gls{rmiae}}(\gls{lambda_hat}) = 
        \mbox{\gls{miae}}(\gls{relative_lambda_hat}) \\
\end{equation}

where \gls{relative_lambda_hat} is defined above in \cref{eq:relative_lambda_hat},
and

\begin{equation}
\label{eq:nmiae}
    \mbox{\gls{nmiae}}(\gls{lambda_hat}) = 
        \frac{1}{\gls{mu}^2} \mbox{\gls{miae}}(\gls{lambda_hat}) \text{.}
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subsection: Max error
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Supremum error}
\label{subsec:method:sup_error}

Whereas the previous two measures of accuracy describe how much the estimated intensity deviates from the truth over the whole plane,
the \gls{supremum error} looks at the worst case.
We define the \gls{supremum error} as follows:

\begin{equation}
    \mbox{supremum error}(\gls{lambda_hat}) = \sup_{(x_1, x_2) \in \gls{W}}
        {\left|
            \gls{lambda_hat}(x_1, x_2) - \lambda(x_1, x_2)
        \right|}
\end{equation}

As in the previous accuracy measures, we run \(M\) monte carlo simulations, and approximate the \mbox{supremum error}, by taking the empirical average of the supremum error of the estimates.

\begin{equation}
    \widetilde{\mbox{\gls{supremum error}}}(\gls{lambda_hat}) = \frac{1}{M} \sum_{i=1}^{M} \mbox{supremum error}(\hat{\lambda_i})
\end{equation}

Furthermore, we need to compare experiments with different values of \gls{mu}.
The analogous definitions are \gls{relative supremum error} and \gls{normalized supremum error}, as defined below.

\begin{equation}
\label{eq:relative_supremum_error}
    \mbox{\gls{relative supremum error}}(\gls{lambda_hat}) = 
        \frac{1}{\lambda_{max}} \mbox{\gls{supremum error}}(\gls{lambda_hat}) \\
\end{equation}

where
\begin{equation}
\label{eq:lambda_max}
    \lambda_{max} = \sup_{(x_1, x_2) \in \gls{W}}{\gls{lambda}(x_1, x_2)} \text{.}
\end{equation}

\begin{equation}
\label{eq:normalized_supremum_error}
    \mbox{\gls{normalized supremum error}}(\gls{lambda_hat}) = 
        \frac{1}{\gls{mu}^2} \mbox{\gls{supremum error}}(\gls{lambda_hat}) \text{.}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subsection: Peak bias and drift
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Peak bias and peak drift}
\label{subsec:method:peak_bias}

The next two accuracy measures compare the estimated risk function's accuracy in computing the peak.
The \gls{peak error} is difference between the maximum value of the \gls{dkd} estimate \gls{lambda_hat} and the maximum of the true risk function \gls{lambda}.
We denote by \gls{peak bias} the mean over the monte carlo simulations of the \gls{peak error}.
The \gls{peak bias} gives us a feel for how much the \gls{dkd} tends to over or underestimate the worst case of the true risk \gls{lambda}.

The second measure associated with the peak we call the \gls{peak drift}.
It is defined as the mean distance between the peak of \gls{lambda_hat} and \gls{lambda}.

The \gls{relative peak bias} is the \gls{peak bias} divided by the value of the true peak.
The \gls{relative peak drift} is the \gls{peak drift} divided by the range of \(x_1\) or \(x_2\), whichever is larger.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Subsection: Centroid bias and drift
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Centroid bias and peak drift}
\label{subsec:method:centroid_bias}

The final two accuracy measures also compare the estimated risk function's accuracy in computing the peak.
In fact, they are nearly identical to the preceding two accuracy measures.
However, unlike the \gls{peak error} and \gls{peak bias}, they do not use the exact peak of \gls{lambda_hat}.
Instead, they use the centroid and average value of \gls{lambda_hat} over the 5\% of the study area where \gls{lambda_hat} is highest.
We call the corresponding accuracy measures \gls{centroid bias} and \gls{centroid drift}.

The \gls{relative centroid bias} is the \gls{centroid bias} divided by the value of the true peak.
The \gls{relative centroid drift} is the \gls{centroid drift} divided by the range of \(x_1\) or \(x_2\), whichever is larger.

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Data generation process
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data generation process}
\label{sec:method:data generation}

We generate data for each experiment as follows.
Before we begin, we set the random number seed to a fixed value for all experiments.
The first step is to generate a population.
We choose a distribution function \(f_p\) over \gls{W}, and scale it to obtain an the population intensity function \gls{lambda_p} of a \gls{spp} \gls{Lambda} with an expected number of points the same as our chosen population size.
This means that the actual population size may not be exactly what we have chosen.
We then generate points \((x_1, x_2)\) uniformly in \gls{W} and use keep them with probability \gls{lambda_p}\((x_1, x_2)\).
This gives us our population \gls{P} which use throughout the experiment.
In this way,
if \gls{lambda_p}\((x_1, x_2)\) has twice the value of \gls{lambda_p}\((y_1, y_2)\) for two points \((x_1, x_2)\) and \((y_1, y_2)\) in \gls{W},
then we expect to see about twice as many points around \((x_1, x_2)\) than around \((y_1, y_2)\) in \gls{P}.

Once we have a fixed population, we have need to decide which members of the population constitute the incidents.
The process to generate the incidents is similar to that of the population.
We create an incident intensity function \gls{lambda_i} of a \gls{spp} for incidents.
We then take the points \((x_1, x_2) \in \gls{P}\) and keep each one with probability \gls{lambda_i}\((x_1, x_2)\).
This gives us our set of incidents \gls{I}.
Once again, when \gls{I}\((x_1, x_2)\) is higher than \gls{I}\((y_1, y_2)\),
then the probability of \((x_1, x_2) \in \gls{I}\) is correspondingly higher than that of \((y_1, y_2)\).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Section: cross-validation bandwidth
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bandwidth selection using cross-validation}
\label{sec:method:cross-validation}

We use cross-validation to select a pair of bandwidths \gls{h_1} and \gls{h_2} that minimize a \gls{cv} error function that approximates the \gls{mise}.
We note that in a real-world situation, the true risk function is unknown, and so it is not possible to compute the \gls{mise}.
In order to compute the \gls{cv} bandwidths, the following steps are taken.
\begin{enumerate}
    \item Generate a set of bandwidths to check.
    \item For each pair of bandwidths \gls{h_1} and \gls{h_2} and each incident \((x_{1,i}, x_{2,i})\) in \gls{I}, generate the estimate of \gls{lambda_hat} by leaving out \((x_{1,i}, x_{2,i})\).
    \item Compute the \gls{cv} error for the bandwidth pair.
    \item Choose the bandwidth pair that minimizes the \gls{cv} error.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Section: experiment structure
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experiment structure}
\label{sec:method:experiment_structure}

In order to ensure repeatability of the experiements, we begin by setting the random number seed to the same fixed value.
We arbitrarily chose the number 12.

The first step in each experimental run is to define the study area \gls{W}. 
The study area is defined as a 2-dimensional rectangle, with coordinates in the \(x_1\) and \(x_2\) directions set using the parameters \textit{x1.min}, \textit{x1.max}, \textit{x2.min}, and \textit{x2.max}.
These are abstract units of distance, that are analogous to kilometers or miles or any other actual unit of distance in which the \gls{dkd} might be used for spatial analysis.
\Gls{W} is further restricted by the \textit{buffer} parameter, which forms a border around the perimeter of the study area.
These parameters that define the study area \gls{W} remained fixed throughout the study.
In particular, we set \texttt{x1.min} to -4, \texttt{x1.max} to 4, \texttt{x2.min} to -4, \texttt{x2.max} to 4, and \texttt{buffer} to 0.5.
This gave us a study area with dimensions \(8 \times 8\), with incidents concentrated in an area of \(7 \times 7\).
For evaluating the \gls{dkd} we used a grid size of 0.5.

Next, a population is generated of size \textit{N.p}.
The population is generated \textbf{once} for the entire experiment, and consists of points \((x_1, x_2) \in \gls{W}\).
When the \textit{c1} and \textit{c2} parameters are given, the population is distributed according to a bivariate normal pattern.
In particular, the population distribution has its center at (\textit{c1}, \textit{c2}),
standard deviations \textit{sigma1}, \textit{sigma2}, \textit{rho}.
In this study, we always use the same value for both directions \textit{sigma1} and \textit{sigma2} and set \textit{rho} to 0 making \(x_1\) and \(x_2\) independent.

Next, we generate the incident risk function, \(\gls{lambda}(x_1, x_2)\), by scaling our base function \(f(x_1, x_2\) it so that the expected number of incidents \gls{mu} is equal to the \textit{EN.i} parameter.
We begin with a function \(f(x_1, x_2)\) defined on \gls{W}, which is positive-valued and has 

\begin{equation*}
    \int_{\gls{W}} {f(x_1, x_2) \diff{x_2} \diff{x_1}} = 1
    \text{.}
\end{equation*}

We define the \textit{true incident risk} function for the experiment

\begin{equation}
    \gls{lambda}(x_1, x_2) = \gls{mu} f(x_1, x_2) \text{.}
\end{equation}

By applying \gls{lambda}, re-scaled according to the population size, on the population points, we generate incidents.
This technique randomly determines whether or not each member of the population is regarded as an incident, with probability according to the value of \gls{lambda}\((x_1, x_2\) at the associated coordinates.

The next step is to compute the \gls{oracle} bandwidths \gls{h_o1} and \gls{h_o2}.
These bandwidths will be used in later steps to compare the accuracy of the \gls{dkd} estimator using multiple bandwidth selection schemes.
The bandwidths \gls{h_o1} and \gls{h_o2} are chosen by running a small number of 49 simulations and taking the bandwidth pair \gls{h_1} and \gls{h_2} that minimize the approximate \gls{mise} which is computed for each pair using \cref{eq:mise}.

We now can begin the main simulations.
For each experiment, we run 1,000 simulations.
In each simulation, we peform the following:
\begin{enumerate}
    \item\label{itm:method:simulation:generate} Generate a sample of incidents \gls{I} from the population \gls{P}, based on the risk function \gls{lambda}.
    \item\label{itm:method:simulation:oracle_lambda_i} Using the \gls{oracle} bandwidths \gls{h_o1} and \gls{h_o2}, compute the \gls{oracle} estimate of \gls{lambda_i}.
    \item\label{itm:method:simulation:oracle_lambda_hat} At each grid point \((x_{1,i}, x_{2,i})\), divide the oracle estimate of \gls{lambda_i}\((x_{1,i}, x_{2,i})\) by \gls{lambda_p}\((x_{i,i}, x_{2,i})\) to obtain \gls{lambda_hat_o}\((x_{1,i}, x_{2,i})\).
    \item\label{itm:method:simulation:accuracy} Compute the accuracy measures \gls{ise}, \gls{iae}, \gls{supremum error}, \gls{peak error}, \gls{peak drift} for the \gls{oracle}.
    Also compute the relative values for these measures.
    \item\label{itm:method:simulation:silverman_lambda_i} Repeat steps \ref{itm:method:simulation:oracle_lambda_i} to \ref{itm:method:simulation:accuracy} using the bandwith computed with \gls{silverman}.
    \item\label{itm:method:simulation:cv_lambda_i} Repeat steps \ref{itm:method:simulation:oracle_lambda_i} to \ref{itm:method:simulation:accuracy} using the bandwidths computed by \gls{cv}.
    This computation is described in \cref{sec:method:cross-validation}.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Section: 
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section[Combining experiments]{Combining experiments to examine the effects of different variables}
\label{sec:method:combining_experiments}

We now take our ability to run experiments under different setups,
and create combinations of experiments that examine the impact of different variables on the various accuracy measures described in \cref{sec:method:accuracy},
and in some cases also on the selected bandwidths.
The first combination will look at how the expected number of incidents for a fixed population size and distribution affects the accuracy and selected bandwidths.
Next, we will examine how the sample size affects the accuracy and bandwidth selection.
We do this by keeping the true risk function fixed, and allowing both the size of the population and the expectd number of incidents vary in tandem.
Third, we examine the effect of the risk function spread on the accuracy, followed by the effect of the population spread.
Finally, we examine the effect of the distance between two peaks in a bimodal risk function affects the accuracy of the estimate.

